<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="./style.css" />
    <title>Shortest Path Using Dijkstra Algorithm</title>
  </head>
  <body>
    <!-- First Navigation Bar -->
    <nav class="navbar top-navbar">
      <div class="title-center">
        <h1>PATH FINDER VISUALIZER</h1>
      </div>
      <div class="nav-right">
        <div class="algo-info-selector">
          <select id="algo-info">
            <option value="">Select Algorithm</option>
            <option value="dfs">Depth First Search</option>
            <option value="bfs">Breadth First Search</option>
            <option value="dijkstra">Dijkstra's Algorithm</option>
            <option value="astar">A* Algorithm</option>
          </select>
          <button class="outline-btn info-btn" onclick="showAlgorithmInfo()">Info</button>
        </div>
      </div>
    </nav>
    
    <!-- Algorithm Info Modal -->
    <div id="algorithm-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal">&times;</span>
        <h2 id="modal-title">Algorithm Information</h2>
        <div id="modal-content"></div>
      </div>
    </div>

    <!-- Second Navigation Bar with Controls -->
    <nav class="navbar control-navbar">
      <div class="simplified-controls">
        <div class="left-controls">
          <div class="algorithm-selector">
            <label for="algorithm">Algorithm:</label>
            <select id="algorithm">
              <option value="bfs">Breadth First Search (BFS)</option>
              <option value="dfs">Depth First Search (DFS)</option>
              <option value="dijkstra">Dijkstra's Algorithm</option>
              <option value="astar">A* Search</option>
            </select>
          </div>
          
          <button class="outline-btn run-btn" onclick="runSelectedAlgorithm(this)">
            Run
          </button>
          
          <button class="outline-btn clear-btn" onclick="clearGrid()">
            Clear
          </button>
        </div>
        
        <div class="right-controls">
          <div class="node-types">
            <div class="node-type">
              <div class="node-color source-node"></div>
              <span>Source</span>
            </div>
            <div class="node-type">
              <div class="node-color target-node"></div>
              <span>Target</span>
            </div>
            <div class="node-type">
              <div class="node-color obstacle-node"></div>
              <span>Obstacle</span>
            </div>
            <div class="node-type">
              <div class="node-color path-node"></div>
              <span>Path</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Hidden inputs for compatibility with existing code -->
      <div style="display: none;">
        <input type="text" id="source-node" value="0" />
        <input type="text" id="target-node" value="1" />
      </div>
    </nav>

    <!-- Main Grid Container -->
    <div class="grid-container">
      <div class="grid" id="pathfinding-grid">
        <!-- Grid cells will be generated by JavaScript -->
      </div>
    </div>

    <!-- Path Information Panel -->
    <div class="path"></div>

    <!-- Footer -->
    <footer>
      <div id="algorithm-stats">
        No algorithm has been run yet. Select source and target points, then click Run.
      </div>
      <button id="help-btn" class="outline-btn" style="position: absolute; right: 15px; font-size: 0.8rem;">Help</button>
    </footer>
    
    <!-- Help Modal -->
    <div id="help-modal" class="modal">
      <div class="modal-content">
        <span class="close-help-modal">&times;</span>
        <h2 id="help-title">Keyboard Shortcuts</h2>
        <div id="help-content">
          <p><strong>W</strong> - Wall tool</p>
          <p><strong>S</strong> - Start point tool</p>
          <p><strong>E</strong> - End point tool</p>
          <p><strong>C</strong> - Clear (erase) tool</p>
          <p><strong>R</strong> - Run algorithm</p>
          <p><strong>X</strong> - Clear grid</p>
          <p><strong>Esc</strong> - Close modal</p>
        </div>
      </div>
    </div>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.1/gsap.min.js"></script>
    <script src="./gsap.js"></script>
    <script src="./script.js"></script>
    <script src="./grid_maze.js"></script>
    <script src="./grid_algorithms.js"></script>
    <script src="./astar_algo.js"></script>
    <script src="./algorithm_comparison.js"></script>
    <script>
      // Function to run the selected algorithm
      function runSelectedAlgorithm(el) {
        const algorithm = document.getElementById('algorithm').value;
        const statsElement = document.getElementById('algorithm-stats');
        statsElement.innerHTML = '<p>Running algorithm...</p>';
        
        // Get start and end cells
        const startCell = document.querySelector('.start-cell');
        const endCell = document.querySelector('.end-cell');
        
        if (!startCell || !endCell) {
          alert('Please set both start and end points');
          statsElement.innerHTML = '<p>Missing start or end point</p>';
          return;
        }
        
        // Clear previous visualization (but keep walls, start, and end)
        clearVisualization();
        
        // Start timing
        const startTime = performance.now();
        
        // Run the selected algorithm on the grid
        runGridAlgorithm(algorithm, startCell, endCell).then(() => {
          updateStats(startTime, algorithm);
        });
      }
      
      // Function to run grid-based algorithm
      async function runGridAlgorithm(algorithm, startCell, endCell) {
        try {
          // Get grid dimensions
          const grid = document.getElementById('pathfinding-grid');
          const cells = Array.from(document.querySelectorAll('.grid-cell'));
          const rows = parseInt(getComputedStyle(grid).gridTemplateRows.split(' ').length);
          const cols = parseInt(getComputedStyle(grid).gridTemplateColumns.split(' ').length);
          
          // Create a 2D grid representation
          const gridArray = Array(rows).fill().map(() => Array(cols).fill(1)); // 1 means passable
          
          // Mark walls as impassable (0)
          document.querySelectorAll('.wall-cell').forEach(wallCell => {
            const row = parseInt(wallCell.dataset.row);
            const col = parseInt(wallCell.dataset.col);
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
              gridArray[row][col] = 0;
            }
          });
          
          // Get start and end positions
          const startRow = parseInt(startCell.dataset.row);
          const startCol = parseInt(startCell.dataset.col);
          const endRow = parseInt(endCell.dataset.row);
          const endCol = parseInt(endCell.dataset.col);
          
          // Validate start and end positions
          if (startRow < 0 || startRow >= rows || startCol < 0 || startCol >= cols ||
              endRow < 0 || endRow >= rows || endCol < 0 || endCol >= cols) {
            alert('Start or end position is out of bounds');
            statsElement.innerHTML = '<p>Invalid start or end position</p>';
            return;
          }
          
          // Check if start or end is on a wall
          if (gridArray[startRow][startCol] === 0) {
            alert('Start position cannot be on a wall');
            statsElement.innerHTML = '<p>Start position on wall</p>';
            return;
          }
          
          if (gridArray[endRow][endCol] === 0) {
            alert('End position cannot be on a wall');
            statsElement.innerHTML = '<p>End position on wall</p>';
            return;
          }
          
          // Run the selected algorithm
          let visited = [];
          let path = [];
          
          switch(algorithm) {
            case 'bfs':
              [visited, path] = await runBFS(gridArray, startRow, startCol, endRow, endCol);
              break;
            case 'dfs':
              [visited, path] = await runDFS(gridArray, startRow, startCol, endRow, endCol);
              break;
            case 'dijkstra':
              [visited, path] = await runDijkstra(gridArray, startRow, startCol, endRow, endCol);
              break;
            case 'astar':
              [visited, path] = await runAStar(gridArray, startRow, startCol, endRow, endCol);
              break;
            default:
              alert('Please select an algorithm');
              return;
          }
          
          // Visualize the visited cells
          for (let i = 0; i < visited.length; i++) {
            const [row, col] = visited[i];
            // Check if cell is within grid bounds (max 19 rows)
            if (row >= 0 && row < 19 && col >= 0 && col < cols) {
              const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
              if (cell && !cell.classList.contains('start-cell') && !cell.classList.contains('end-cell')) {
                cell.classList.add('visited-cell');
                await new Promise(resolve => setTimeout(resolve, 10));
              }
            }
          }
          
          // Visualize the path
          for (let i = 0; i < path.length; i++) {
            const [row, col] = path[i];
            // Check if cell is within grid bounds (max 19 rows)
            if (row >= 0 && row < 19 && col >= 0 && col < cols) {
              const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
              if (cell && !cell.classList.contains('start-cell') && !cell.classList.contains('end-cell')) {
                cell.classList.add('shortest-path-cell');
                await new Promise(resolve => setTimeout(resolve, 50));
              }
            }
          }
          
          // Check if path is empty (no path found)
          if (path.length === 0 && visited.length > 0) {
            alert('No path found between start and end points!');
            const statsElement = document.getElementById('algorithm-stats');
            statsElement.innerHTML = 'No path found between start and end points! Try removing some obstacles.';
          }
          
          return Promise.resolve();
        } catch (error) {
          console.error('Error in pathfinding:', error);
          alert('An error occurred during pathfinding');
          return Promise.resolve();
        }
      }
      
      // Clear visualization but keep walls, start, and end
      function clearVisualization() {
        const cells = document.querySelectorAll('.grid-cell');
        cells.forEach(cell => {
          cell.classList.remove('visited-cell', 'shortest-path-cell');
        });
      }
      
      // Clear the entire grid
      function clearGrid() {
        const cells = document.querySelectorAll('.grid-cell');
        cells.forEach(cell => {
          cell.classList.remove('wall-cell', 'start-cell', 'end-cell', 'visited-cell', 'shortest-path-cell');
        });
        
        // Reset stats
        const statsElement = document.getElementById('algorithm-stats');
        statsElement.innerHTML = 'Grid cleared. Select source and target points, then run an algorithm.';
      }
      
      // Function to update stats in footer
      function updateStats(startTime, algorithmName) {
        const endTime = performance.now();
        const executionTime = ((endTime - startTime) / 1000).toFixed(2);
        
        // Count visited cells and path length
        const visitedCells = document.querySelectorAll('.visited-cell').length;
        const pathCells = document.querySelectorAll('.shortest-path-cell').length;
        
        // Format algorithm name for display
        let algoName = algorithmName;
        switch(algorithmName) {
          case 'bfs':
            algoName = 'Breadth First Search';
            break;
          case 'dfs':
            algoName = 'Depth First Search';
            break;
          case 'dijkstra':
            algoName = 'Dijkstra\'s Algorithm';
            break;
          case 'astar':
            algoName = 'A* Search';
            break;
        }
        
        const statsElement = document.getElementById('algorithm-stats');
        statsElement.innerHTML = `Algorithm: <span style="color:#fff">${algoName}</span> | Execution Time: <span style="color:#fff">${executionTime}s</span> | Cells Visited: <span style="color:#fff">${visitedCells}</span> | Path Length: <span style="color:#fff">${pathCells}</span>`;
      }
      
      // Function to show algorithm information
      function showAlgorithmInfo() {
        const algoSelect = document.getElementById('algo-info');
        const selectedAlgo = algoSelect.value;
        const modal = document.getElementById('algorithm-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        
        if (!selectedAlgo) {
          alert('Please select an algorithm first');
          return;
        }
        
        // Set modal title
        modalTitle.textContent = algoSelect.options[algoSelect.selectedIndex].text;
        
        // Set modal content based on selected algorithm
        switch (selectedAlgo) {
          case 'dfs':
            modalContent.innerHTML = `
              <p>Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures.</p>
              <p><strong>How it works:</strong> The algorithm starts at the root node and explores as far as possible along each branch before backtracking.</p>
              <p><strong>Time Complexity:</strong> O(V + E) where V is the number of vertices and E is the number of edges.</p>
              <p><strong>Space Complexity:</strong> O(V) in the worst case.</p>
              <p><strong>Use Cases:</strong> Topological sorting, finding connected components, solving puzzles with only one solution.</p>
            `;
            break;
          case 'bfs':
            modalContent.innerHTML = `
              <p>Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures.</p>
              <p><strong>How it works:</strong> The algorithm starts at the root node and explores all neighbor nodes at the present depth before moving on to nodes at the next depth level.</p>
              <p><strong>Time Complexity:</strong> O(V + E) where V is the number of vertices and E is the number of edges.</p>
              <p><strong>Space Complexity:</strong> O(V) in the worst case.</p>
              <p><strong>Use Cases:</strong> Finding shortest path on unweighted graphs, finding all nodes within one connected component.</p>
            `;
            break;
          case 'dijkstra':
            modalContent.innerHTML = `
              <p>Dijkstra's Algorithm is an algorithm for finding the shortest paths between nodes in a weighted graph.</p>
              <p><strong>How it works:</strong> The algorithm maintains a set of unvisited nodes and calculates the tentative distance to each node. It repeatedly selects the node with the smallest tentative distance and updates the distances to its neighbors.</p>
              <p><strong>Time Complexity:</strong> O((V + E) log V) with a binary heap implementation.</p>
              <p><strong>Space Complexity:</strong> O(V) where V is the number of vertices.</p>
              <p><strong>Use Cases:</strong> Finding shortest path in maps, network routing protocols.</p>
            `;
            break;
          case 'astar':
            modalContent.innerHTML = `
              <p>A* (A-Star) is an informed search algorithm used for pathfinding and graph traversal.</p>
              <p><strong>How it works:</strong> A* uses a heuristic function to estimate the cost from the current node to the goal, and combines it with the actual cost from the start node to the current node.</p>
              <p><strong>Time Complexity:</strong> O(E) where E is the number of edges, but depends heavily on the heuristic.</p>
              <p><strong>Space Complexity:</strong> O(V) where V is the number of vertices.</p>
              <p><strong>Use Cases:</strong> Pathfinding in games, robot navigation, route planning.</p>
            `;
            break;
          default:
            modalContent.innerHTML = '<p>Select an algorithm to see information about it.</p>';
        }
        
        // Show the modal
        modal.style.display = 'block';
      }
      
      // Initialize grid and modal when page loads
      document.addEventListener('DOMContentLoaded', function() {
        initializeGrid();
        
        // Set up modal close button
        const modal = document.getElementById('algorithm-modal');
        const closeBtn = document.querySelector('.close-modal');
        
        closeBtn.onclick = function() {
          modal.style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
          if (event.target === modal) {
            modal.style.display = 'none';
          }
        }
        
        // Setup help modal
        const helpModal = document.getElementById('help-modal');
        const helpBtn = document.getElementById('help-btn');
        const closeHelpBtn = document.querySelector('.close-help-modal');
        
        helpBtn.onclick = function() {
          helpModal.style.display = 'block';
        }
        
        closeHelpBtn.onclick = function() {
          helpModal.style.display = 'none';
        }
        
        // Close help modal when clicking outside of it
        window.addEventListener('click', function(event) {
          if (event.target === helpModal) {
            helpModal.style.display = 'none';
          }
        });
        
        // Add keyboard accessibility
        document.addEventListener('keydown', function(event) {
          // Escape key closes modals
          if (event.key === 'Escape') {
            if (modal.style.display === 'block') {
              modal.style.display = 'none';
            }
            if (helpModal.style.display === 'block') {
              helpModal.style.display = 'none';
            }
          }
          
          // Keyboard shortcuts for tools
          switch(event.key) {
            case 'w': // Wall
              document.querySelector('.node-type:nth-child(3)').click();
              break;
            case 's': // Start
              document.querySelector('.node-type:nth-child(1)').click();
              break;
            case 'e': // End
              document.querySelector('.node-type:nth-child(2)').click();
              break;
            case 'c': // Clear (erase)
              document.querySelector('.node-type:nth-child(4)').click();
              break;
            case 'r': // Run
              document.querySelector('.run-btn').click();
              break;
            case 'x': // Clear grid
              document.querySelector('.clear-btn').click();
              break;
          }
        });
      });
    </script>
  </body>
</html>